

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Connection Adapters &mdash; Pika 0.9a documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.9a',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Pika 0.9a documentation" href="index.html" />
    <link rel="next" title="Callback" href="callback.html" />
    <link rel="prev" title="Introduction to Pika" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="callback.html" title="Callback"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Introduction to Pika"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Pika 0.9a documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="connection-adapters">
<h1>Connection Adapters<a class="headerlink" href="#connection-adapters" title="Permalink to this headline">¶</a></h1>
<p>Pika provides multiple adapters to connect to RabbitMQ allowing for different ways of providing socket communication depending on what is appropriate for your application.</p>
<ul class="simple">
<li><a class="reference internal" href="#selectconnection"><em>SelectConnection</em></a>: A native event based connection adapter that implements select, kqueue, poll and epoll.</li>
<li><a class="reference internal" href="#asyncoreconnection"><em>AsyncoreConnection</em></a>: Legacy adapter kept for convenience of previous Pika users.</li>
<li><a class="reference internal" href="#tornadoconnection"><em>TornadoConnection</em></a>: Connection adapter for use with the Tornado IO Loop.</li>
<li><a class="reference internal" href="#blockingconnection"><em>BlockingConnection</em></a>: Enables blocking, synchronous operation on top of library for simple uses.</li>
</ul>
<div class="section" id="tcp-backpressure">
<h2>TCP Backpressure<a class="headerlink" href="#tcp-backpressure" title="Permalink to this headline">¶</a></h2>
<p>As of RabbitMQ 2.0.0, client side Channel.Flow has been removed. Instead, the RabbitMQ broker uses TCP Backpressure to slow your client if it is
delivering messages too fast. Pika attempts to help you handle this situation by providing a mechanism by which you may be notified if Pika has noticed
too many frames have yet to be delivered. By registering a function with the <em>add_backpressure_callback</em> function of any connection adapter, your function
will be called when Pika sees that a backlog of 10 times the average frame size you have been sending has been exceeded. You may tweak this value by
calling the set_backpressure_multiplier method passing any integer value.</p>
</div>
<div class="section" id="io-and-event-looping">
<h2>IO and Event Looping<a class="headerlink" href="#io-and-event-looping" title="Permalink to this headline">¶</a></h2>
<p>Due to the need to check for and send content on a consistent basis, Pika now implements or extends IOLoops in each of its asynchronous connection adapters. These IOLoops
are blocking methods which loop and listen for events. Each asynchronous adapters follows the same standard for invoking the IOLoop. If you are using an external IOLoop
such as Tornado&#8217;s IOLoop, you may invoke that as you normally would and then add the adapter to it.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">parameters</span> <span class="o">=</span> <span class="n">pika</span><span class="o">.</span><span class="n">ConnectionParameters</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
<span class="n">connection</span> <span class="o">=</span> <span class="n">SelectConnection</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">on_connected</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">ioloop</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">ioloop</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="continuation-passing-style">
<h2>Continuation-Passing Style<a class="headerlink" href="#continuation-passing-style" title="Permalink to this headline">¶</a></h2>
<p>Interfacing with Pika asynchronously is done by passing in callback methods you would like to have invoked when a certain event has completed. For example, if you are going to declare a queue, you pass in a method that will be called when the RabbitMQ server returns a &#8220;Queue.DeclareOk&#8221; response.</p>
<p>In our example below we use the following four easy steps:</p>
<ol class="arabic simple">
<li>We start by creating our connection object, then starting our event loop.</li>
<li>When we are connected, the <em>on_connected</em> method is called. In that method we create a channel.</li>
<li>When the channel is created, the <em>on_channel_open</em> method is called. In that method we declare a queue.</li>
<li>When the queue is declared successfully, <em>on_queue_declared</em> is called. In that method we call channel.basic_consume telling it to call the handle_delivery for each message RabbitMQ delivers to us.</li>
</ol>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pika.adapters</span> <span class="kn">import</span> <span class="n">SelectConnection</span>

<span class="c"># Create a global channel variable to hold our channel object in</span>
<span class="n">channel</span> <span class="o">=</span> <span class="bp">None</span>

<span class="c"># Step #2</span>
<span class="k">def</span> <span class="nf">on_connected</span><span class="p">(</span><span class="n">connection</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Called when we are fully connected to RabbitMQ&quot;&quot;&quot;</span>
    <span class="c"># Open a channel</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">channel</span><span class="p">(</span><span class="n">on_channel_open</span><span class="p">)</span>

<span class="c"># Step #3</span>
<span class="k">def</span> <span class="nf">on_channel_open</span><span class="p">(</span><span class="n">new_channel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Called when our channel has opened&quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">channel</span>
    <span class="n">channel</span> <span class="o">=</span> <span class="n">new_channel</span>
    <span class="n">channel</span><span class="o">.</span><span class="n">queue_declare</span><span class="p">(</span><span class="n">queue</span><span class="o">=</span><span class="s">&quot;test&quot;</span><span class="p">,</span> <span class="n">durable</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">exclusive</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">auto_delete</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">on_queue_declared</span><span class="p">)</span>

<span class="c"># Step #4</span>
<span class="k">def</span> <span class="nf">on_queue_declared</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Called when RabbitMQ has told us our Queue has been declared, frame is the response from RabbitMQ&quot;&quot;&quot;</span>
    <span class="n">channel</span><span class="o">.</span><span class="n">basic_consume</span><span class="p">(</span><span class="n">handle_delivery</span><span class="p">,</span> <span class="n">queue</span><span class="o">=</span><span class="s">&#39;test&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">handle_delivery</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">body</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Called when we receive a message from RabbitMQ&quot;&quot;&quot;</span>
    <span class="k">print</span> <span class="n">body</span>

<span class="c"># Step #1: Connect to RabbitMQ</span>
<span class="n">connection</span> <span class="o">=</span> <span class="n">SelectConnection</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">on_connected</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="c"># Loop so we can communicate with RabbitMQ</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">ioloop</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
    <span class="c"># Gracefully close the connection</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="c"># Loop until we&#39;re fully closed, will stop on its own</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">ioloop</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="available-adapters">
<h2>Available Adapters<a class="headerlink" href="#available-adapters" title="Permalink to this headline">¶</a></h2>
<div class="section" id="selectconnection">
<span id="id1"></span><h3>SelectConnection<a class="headerlink" href="#selectconnection" title="Permalink to this headline">¶</a></h3>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">SelectConnection is the recommended method for using Pika under most
circumstances. It supports multiple event notification methods including select, epoll, kqueue and poll.</p>
</div>
<p>By default SelectConnection will attempt to use the most appropriate event
notification method for your system. In order to override the default behavior
you may set the poller type by assigning a string value to the
select_connection modules POLLER_TYPE attribute prior to creating the
SelectConnection object instance. Valid values are: kqueue, poll, epoll, select</p>
<p>Poller Type Override Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">select_connection</span>
<span class="n">select_connection</span><span class="o">.</span><span class="n">POLLER_TYPE</span> <span class="o">=</span> <span class="s">&#39;epoll&#39;</span>
<span class="n">connection</span> <span class="o">=</span> <span class="n">select_connection</span><span class="o">.</span><span class="n">SelectConnection</span><span class="p">()</span>
</pre></div>
</div>
<span class="target" id="module-adapters.select_connection"></span><dl class="class">
<dt id="adapters.select_connection.SelectConnection">
<em class="property">class </em><tt class="descclassname">adapters.select_connection.</tt><tt class="descname">SelectConnection</tt><big>(</big><em>parameters</em>, <em>on_open_callback</em>, <em>reconnection_strategy=None</em><big>)</big><a class="headerlink" href="#adapters.select_connection.SelectConnection" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="adapters.select_connection.SelectConnection.add_backpressure_callback">
<tt class="descname">add_backpressure_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#adapters.select_connection.SelectConnection.add_backpressure_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a callback notification when we think backpressue is being applied
due to the size of the output buffer being exceeded. We calculate this
by figuring the average frame size and then checking to see if our
backpressure multiplier * average frame size has been exceeded.
You can change the backpressure multiplier by calling the
set_backpressure_multiplier.</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.SelectConnection.add_on_close_callback">
<tt class="descname">add_on_close_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#adapters.select_connection.SelectConnection.add_on_close_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a callback notification when the connection has closed</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.SelectConnection.add_on_open_callback">
<tt class="descname">add_on_open_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#adapters.select_connection.SelectConnection.add_on_open_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a callback notification when the connection has closed</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.SelectConnection.channel">
<tt class="descname">channel</tt><big>(</big><em>on_open_callback</em>, <em>channel_number=None</em><big>)</big><a class="headerlink" href="#adapters.select_connection.SelectConnection.channel" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new channel with the next available or specified channel #</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.SelectConnection.close">
<tt class="descname">close</tt><big>(</big><em>code=200</em>, <em>text='Normal shutdown'</em><big>)</big><a class="headerlink" href="#adapters.select_connection.SelectConnection.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Disconnect from RabbitMQ. If there are any open channels, it will
attempt to close them prior to fully disconnecting. Channels which
have active consumers will attempt to send a Basic.Cancel to RabbitMQ
to cleanly stop the delivery of messages prior to closing the channel.</p>
</dd></dl>

<dl class="attribute">
<dt id="adapters.select_connection.SelectConnection.is_open">
<tt class="descname">is_open</tt><a class="headerlink" href="#adapters.select_connection.SelectConnection.is_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a boolean reporting the current connection state</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.SelectConnection.set_backpressure_multiplier">
<tt class="descname">set_backpressure_multiplier</tt><big>(</big><em>value=10</em><big>)</big><a class="headerlink" href="#adapters.select_connection.SelectConnection.set_backpressure_multiplier" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter the backpressure multiplier value. We set this to 10 by default.
This value is used to raise warnings and trigger the backpressure
callback.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="asyncoreconnection">
<span id="id2"></span><h3>AsyncoreConnection<a class="headerlink" href="#asyncoreconnection" title="Permalink to this headline">¶</a></h3>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">SelectConnection is the recommended method for using Pika under most
circumstances.</p>
</div>
<p>The AsyncoreConnection class is provided for legacy support and quicker porting from applications that used Pika version 0.5.2 and prior.</p>
<span class="target" id="module-adapters.asyncore_connection"></span><dl class="class">
<dt id="adapters.asyncore_connection.AsyncoreConnection">
<em class="property">class </em><tt class="descclassname">adapters.asyncore_connection.</tt><tt class="descname">AsyncoreConnection</tt><big>(</big><em>parameters</em>, <em>on_open_callback</em>, <em>reconnection_strategy=None</em><big>)</big><a class="headerlink" href="#adapters.asyncore_connection.AsyncoreConnection" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="adapters.asyncore_connection.AsyncoreConnection.add_backpressure_callback">
<tt class="descname">add_backpressure_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#adapters.asyncore_connection.AsyncoreConnection.add_backpressure_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a callback notification when we think backpressue is being applied
due to the size of the output buffer being exceeded. We calculate this
by figuring the average frame size and then checking to see if our
backpressure multiplier * average frame size has been exceeded.
You can change the backpressure multiplier by calling the
set_backpressure_multiplier.</p>
</dd></dl>

<dl class="method">
<dt id="adapters.asyncore_connection.AsyncoreConnection.add_on_close_callback">
<tt class="descname">add_on_close_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#adapters.asyncore_connection.AsyncoreConnection.add_on_close_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a callback notification when the connection has closed</p>
</dd></dl>

<dl class="method">
<dt id="adapters.asyncore_connection.AsyncoreConnection.add_on_open_callback">
<tt class="descname">add_on_open_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#adapters.asyncore_connection.AsyncoreConnection.add_on_open_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a callback notification when the connection has closed</p>
</dd></dl>

<dl class="method">
<dt id="adapters.asyncore_connection.AsyncoreConnection.channel">
<tt class="descname">channel</tt><big>(</big><em>on_open_callback</em>, <em>channel_number=None</em><big>)</big><a class="headerlink" href="#adapters.asyncore_connection.AsyncoreConnection.channel" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new channel with the next available or specified channel #</p>
</dd></dl>

<dl class="method">
<dt id="adapters.asyncore_connection.AsyncoreConnection.close">
<tt class="descname">close</tt><big>(</big><em>code=200</em>, <em>text='Normal shutdown'</em><big>)</big><a class="headerlink" href="#adapters.asyncore_connection.AsyncoreConnection.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Disconnect from RabbitMQ. If there are any open channels, it will
attempt to close them prior to fully disconnecting. Channels which
have active consumers will attempt to send a Basic.Cancel to RabbitMQ
to cleanly stop the delivery of messages prior to closing the channel.</p>
</dd></dl>

<dl class="attribute">
<dt id="adapters.asyncore_connection.AsyncoreConnection.is_open">
<tt class="descname">is_open</tt><a class="headerlink" href="#adapters.asyncore_connection.AsyncoreConnection.is_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a boolean reporting the current connection state</p>
</dd></dl>

<dl class="method">
<dt id="adapters.asyncore_connection.AsyncoreConnection.set_backpressure_multiplier">
<tt class="descname">set_backpressure_multiplier</tt><big>(</big><em>value=10</em><big>)</big><a class="headerlink" href="#adapters.asyncore_connection.AsyncoreConnection.set_backpressure_multiplier" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter the backpressure multiplier value. We set this to 10 by default.
This value is used to raise warnings and trigger the backpressure
callback.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="tornadoconnection">
<span id="id3"></span><h3>TornadoConnection<a class="headerlink" href="#tornadoconnection" title="Permalink to this headline">¶</a></h3>
<p>Tornado is an open source version of the scalable, non-blocking web server and tools that power FriendFeed. For more information on tornado, visit <a class="reference external" href="http://tornadoweb.org">http://tornadoweb.org</a></p>
<p>Since the Tornado IOLoop blocks once it is started, it is suggested that you use a timer to add Pika to your tornado.Application instance after the HTTPServer has started.</p>
<p>The following is a simple, non-working example on how to add Pika to the Tornado IOLoop without blocking other applications from doing so. To see a fully workng example,
see the Tornado Demo application in the examples.</p>
<p>Example:</p>
<div class="highlight-python"><pre>from pika.adapters.tornado_connection import TornadoConnection()

class PikaClient(object):
    def connect(self):
        self.connection = TornadoConnection(on_connected_callback=self.on_connected)

# Create our Tornado Application
application = tornado.web.Application([
    (r"/", ExampleHandler)
], **settings)

# Create our Pika Client
application.pika = PikaClient()

# Start the HTTPServer
http_server = tornado.httpserver.HTTPServer(application)
http_server.listen(8080)

# Get a handle to the instance of IOLoop
ioloop = tornado.ioloop.IOLoop.instance()

# Add our Pika connect to the IOLoop since we loop on ioloop.start
ioloop.add_timeout(500, application.pika.connect)

# Start the IOLoop
ioloop.start()</pre>
</div>
<span class="target" id="module-adapters.tornado_connection"></span><dl class="class">
<dt id="adapters.tornado_connection.TornadoConnection">
<em class="property">class </em><tt class="descclassname">adapters.tornado_connection.</tt><tt class="descname">TornadoConnection</tt><big>(</big><em>parameters</em>, <em>on_open_callback</em>, <em>reconnection_strategy=None</em><big>)</big><a class="headerlink" href="#adapters.tornado_connection.TornadoConnection" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="adapters.tornado_connection.TornadoConnection.add_backpressure_callback">
<tt class="descname">add_backpressure_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#adapters.tornado_connection.TornadoConnection.add_backpressure_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a callback notification when we think backpressue is being applied
due to the size of the output buffer being exceeded. We calculate this
by figuring the average frame size and then checking to see if our
backpressure multiplier * average frame size has been exceeded.
You can change the backpressure multiplier by calling the
set_backpressure_multiplier.</p>
</dd></dl>

<dl class="method">
<dt id="adapters.tornado_connection.TornadoConnection.add_on_close_callback">
<tt class="descname">add_on_close_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#adapters.tornado_connection.TornadoConnection.add_on_close_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a callback notification when the connection has closed</p>
</dd></dl>

<dl class="method">
<dt id="adapters.tornado_connection.TornadoConnection.add_on_open_callback">
<tt class="descname">add_on_open_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#adapters.tornado_connection.TornadoConnection.add_on_open_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a callback notification when the connection has closed</p>
</dd></dl>

<dl class="method">
<dt id="adapters.tornado_connection.TornadoConnection.channel">
<tt class="descname">channel</tt><big>(</big><em>on_open_callback</em>, <em>channel_number=None</em><big>)</big><a class="headerlink" href="#adapters.tornado_connection.TornadoConnection.channel" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new channel with the next available or specified channel #</p>
</dd></dl>

<dl class="method">
<dt id="adapters.tornado_connection.TornadoConnection.close">
<tt class="descname">close</tt><big>(</big><em>code=200</em>, <em>text='Normal shutdown'</em><big>)</big><a class="headerlink" href="#adapters.tornado_connection.TornadoConnection.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Disconnect from RabbitMQ. If there are any open channels, it will
attempt to close them prior to fully disconnecting. Channels which
have active consumers will attempt to send a Basic.Cancel to RabbitMQ
to cleanly stop the delivery of messages prior to closing the channel.</p>
</dd></dl>

<dl class="attribute">
<dt id="adapters.tornado_connection.TornadoConnection.is_open">
<tt class="descname">is_open</tt><a class="headerlink" href="#adapters.tornado_connection.TornadoConnection.is_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a boolean reporting the current connection state</p>
</dd></dl>

<dl class="method">
<dt id="adapters.tornado_connection.TornadoConnection.set_backpressure_multiplier">
<tt class="descname">set_backpressure_multiplier</tt><big>(</big><em>value=10</em><big>)</big><a class="headerlink" href="#adapters.tornado_connection.TornadoConnection.set_backpressure_multiplier" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter the backpressure multiplier value. We set this to 10 by default.
This value is used to raise warnings and trigger the backpressure
callback.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="blockingconnection">
<span id="id4"></span><h3>BlockingConnection<a class="headerlink" href="#blockingconnection" title="Permalink to this headline">¶</a></h3>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p class="last">BlockingConnection is provided for legacy and learning purposes only and it is not recommended that you use it for a production application.</p>
</div>
<p>The BlockingConnection creates a layer on top of Pika&#8217;s asynchronous core providng methods that will block until their expected response has returned.
Due to the asynchronous nature of the Basic.Deliver and Basic.Return calls from RabbitMQ to your application, you are still required to implement
continuation-passing style asynchronous methods if you&#8217;d like to receive messages from RabbitMQ using basic_consume or if you want to be notified of
a delivery failure when using basic_publish.</p>
<p>Basic.Get is a blocking call which will either return the Method Frame, Header Frame and Body of a message, or it will return a Basic.GetEmpty frame as the Method Frame.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Open a connection to RabbitMQ on localhost using all default parameters</span>
<span class="n">connection</span> <span class="o">=</span> <span class="n">BlockingConnection</span><span class="p">()</span>

<span class="c"># Open the channel</span>
<span class="n">channel</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">channel</span><span class="p">()</span>

<span class="c"># Declare the queue</span>
<span class="n">channel</span><span class="o">.</span><span class="n">queue_declare</span><span class="p">(</span><span class="n">queue</span><span class="o">=</span><span class="s">&quot;test&quot;</span><span class="p">,</span> <span class="n">durable</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">exclusive</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">auto_delete</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="n">channel</span><span class="o">.</span><span class="n">basic_publish</span><span class="p">(</span><span class="n">exchange</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">routing_key</span><span class="o">=</span><span class="s">&quot;test&quot;</span><span class="p">,</span> <span class="n">body</span><span class="o">=</span><span class="s">&quot;Hello World!&quot;</span><span class="p">,</span>
                      <span class="n">properties</span><span class="o">=</span><span class="n">pika</span><span class="o">.</span><span class="n">BasicProperties</span><span class="p">(</span><span class="n">content_type</span><span class="o">=</span><span class="s">&quot;text/plain&quot;</span><span class="p">,</span> <span class="n">delivery_mode</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<span class="target" id="module-adapters.blocking_connection"></span><dl class="class">
<dt id="adapters.blocking_connection.BlockingConnection">
<em class="property">class </em><tt class="descclassname">adapters.blocking_connection.</tt><tt class="descname">BlockingConnection</tt><big>(</big><em>parameters</em>, <em>reconnection_strategy=None</em><big>)</big><a class="headerlink" href="#adapters.blocking_connection.BlockingConnection" title="Permalink to this definition">¶</a></dt>
<dd><p>The BlockingConnection adapter is meant for simple implementations where
you want to have blocking behavior. The behavior layered on top of the
async library. Because of the nature of AMQP there are a few callbacks
one needs to do, even in a blocking implementation. These include receiving
messages from Basic.Deliver, Basic.GetOk, and Basic.Return.</p>
<p>It is also advised that you register callbacks for detecting backpressure.
New to the RabbitMQ 2.0 and higher versions is the removal of Channel.Flow
and instead the application of tcp backpressure when the broker is</p>
<dl class="method">
<dt id="adapters.blocking_connection.BlockingConnection.add_backpressure_callback">
<tt class="descname">add_backpressure_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#adapters.blocking_connection.BlockingConnection.add_backpressure_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a callback notification when we think backpressue is being applied
due to the size of the output buffer being exceeded. We calculate this
by figuring the average frame size and then checking to see if our
backpressure multiplier * average frame size has been exceeded.
You can change the backpressure multiplier by calling the
set_backpressure_multiplier.</p>
</dd></dl>

<dl class="method">
<dt id="adapters.blocking_connection.BlockingConnection.add_on_close_callback">
<tt class="descname">add_on_close_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#adapters.blocking_connection.BlockingConnection.add_on_close_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a callback notification when the connection has closed</p>
</dd></dl>

<dl class="method">
<dt id="adapters.blocking_connection.BlockingConnection.add_on_open_callback">
<tt class="descname">add_on_open_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#adapters.blocking_connection.BlockingConnection.add_on_open_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a callback notification when the connection has closed</p>
</dd></dl>

<dl class="method">
<dt id="adapters.blocking_connection.BlockingConnection.channel">
<tt class="descname">channel</tt><big>(</big><em>channel_number=None</em><big>)</big><a class="headerlink" href="#adapters.blocking_connection.BlockingConnection.channel" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new channel with the next available or specified channel #</p>
</dd></dl>

<dl class="attribute">
<dt id="adapters.blocking_connection.BlockingConnection.is_open">
<tt class="descname">is_open</tt><a class="headerlink" href="#adapters.blocking_connection.BlockingConnection.is_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a boolean reporting the current connection state</p>
</dd></dl>

<dl class="method">
<dt id="adapters.blocking_connection.BlockingConnection.set_backpressure_multiplier">
<tt class="descname">set_backpressure_multiplier</tt><big>(</big><em>value=10</em><big>)</big><a class="headerlink" href="#adapters.blocking_connection.BlockingConnection.set_backpressure_multiplier" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter the backpressure multiplier value. We set this to 10 by default.
This value is used to raise warnings and trigger the backpressure
callback.</p>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Connection Adapters</a><ul>
<li><a class="reference internal" href="#tcp-backpressure">TCP Backpressure</a></li>
<li><a class="reference internal" href="#io-and-event-looping">IO and Event Looping</a></li>
<li><a class="reference internal" href="#continuation-passing-style">Continuation-Passing Style</a></li>
<li><a class="reference internal" href="#available-adapters">Available Adapters</a><ul>
<li><a class="reference internal" href="#selectconnection">SelectConnection</a></li>
<li><a class="reference internal" href="#asyncoreconnection">AsyncoreConnection</a></li>
<li><a class="reference internal" href="#tornadoconnection">TornadoConnection</a></li>
<li><a class="reference internal" href="#blockingconnection">BlockingConnection</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Introduction to Pika</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="callback.html"
                        title="next chapter">Callback</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/adapters.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="callback.html" title="Callback"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Introduction to Pika"
             >previous</a> |</li>
        <li><a href="index.html">Pika 0.9a documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Tony Garnock-Jones, Gavin M. Roy and others.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1pre.
    </div>
  </body>
</html>